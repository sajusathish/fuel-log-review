<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Daily Fuel Log Review</title>
  <style>
    /* Same styles as before ‚Äì no change needed */
    /* (Styles omitted here for brevity since only logic changed) */
  </style>
</head>
<body>
  <h3>Daily Fuel Log Review - <span id="todayDate"></span></h3>

  <div id="tableContainer">
    <p style="text-align:center; color: #666;">Loading table data...</p>
  </div>

  <div class="buttons">
    <button class="refresh" id="refreshBtn">üîÑ Refresh Table</button>
    <button class="approve" id="approveBtn">‚úÖ Approve</button>
    <button class="reject" id="rejectBtn">‚ùå Reject</button>
  </div>

  <div id="statusText"></div>

  <script>
    function base64UrlDecode(input) {
      try {
        const base64 = input.replace(/-/g, '+').replace(/_/g, '/');
        const decoded = atob(base64);
        return decodeURIComponent(escape(decoded));
      } catch (e) {
        console.error("Error decoding base64:", e);
        return null;
      }
    }

    function addSelectAllControl() {
      const table = document.querySelector("table");
      if (!table) return;

      const headerRow = table.querySelector("thead tr");
      const selectIndex = Array.from(headerRow.children).findIndex(th =>
        th.textContent.trim().toLowerCase() === "select"
      );
      if (selectIndex === -1) return;

      const selectAllTh = headerRow.children[selectIndex];
      const selectAllCheckbox = document.createElement("input");
      selectAllCheckbox.type = "checkbox";
      selectAllCheckbox.title = "Select/Deselect All";

      selectAllCheckbox.addEventListener("change", () => {
        const checkboxes = document.querySelectorAll("input[type='checkbox'][name='selectForm']");
        checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
      });

      selectAllTh.innerHTML = "";
      selectAllTh.appendChild(selectAllCheckbox);
    }

    function addColumnResizers() {
      const table = document.querySelector("table");
      if (!table) return;

      const thElements = table.querySelectorAll("thead th");
      thElements.forEach(th => {
        const oldHandle = th.querySelector(".resize-handle");
        if (oldHandle) oldHandle.remove();

        const handle = document.createElement("div");
        handle.className = "resize-handle";
        th.appendChild(handle);

        let startX, startWidth;
        handle.addEventListener('mousedown', e => {
          startX = e.pageX;
          startWidth = th.offsetWidth;
          document.body.style.cursor = 'col-resize';

          function onMouseMove(eMove) {
            const newWidth = startWidth + (eMove.pageX - startX);
            if (newWidth > 40) {
              th.style.width = newWidth + "px";
            }
          }

          function onMouseUp() {
            document.body.style.cursor = '';
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('mouseup', onMouseUp);
          }

          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });
      });
    }

    document.getElementById("todayDate").textContent = new Date().toISOString().split("T")[0];

    const params = new URLSearchParams(window.location.search);
    const dataEncoded = params.get('data');
    const reviewer = params.get('reviewer') || 'unknown@domain.com';

    if (dataEncoded) {
      const tableHTML = base64UrlDecode(dataEncoded);
      if (tableHTML) {
        document.getElementById("tableContainer").innerHTML = tableHTML;
        addSelectAllControl();
        addColumnResizers();
      } else {
        document.getElementById("tableContainer").innerHTML = "<p style='color:red; text-align:center;'>Error loading table data.</p>";
      }
    } else {
      document.getElementById("tableContainer").innerHTML = "<p style='color:gray; text-align:center;'>No initial data provided.</p>";
    }

    function getSelectedFormIds() {
      return Array.from(document.querySelectorAll("input[type='checkbox'][name='selectForm']:checked"))
        .map(cb => cb.value).join(",");
    }

    function toggleButtonsDisabled(disabled) {
      document.getElementById("refreshBtn").disabled = disabled;
      document.getElementById("approveBtn").disabled = disabled;
      document.getElementById("rejectBtn").disabled = disabled;
    }

    async function handleDecision(status) {
      const formIds = getSelectedFormIds();
      const statusText = document.getElementById("statusText");
      if (!formIds) {
        alert("Please select at least one form.");
        return;
      }

      const webhookUrl = `https://webhooks.workato.com/webhooks/rest/b7ed69d5-2da6-44d3-befd-c64b497884e8/fuel-log-response?status=${encodeURIComponent(status)}&Reviewer=${encodeURIComponent(reviewer)}&Form_Ids=${encodeURIComponent(formIds)}`;
      statusText.textContent = `Submitting ${status}...`;
      toggleButtonsDisabled(true);

      try {
        const response = await fetch(webhookUrl, { method: 'GET' });
        if (!response.ok) throw new Error("Webhook call failed");
        statusText.textContent = `‚úÖ ${status} request sent successfully!`;
      } catch (error) {
        statusText.textContent = `‚ùå Error: ${error.message}`;
      } finally {
        toggleButtonsDisabled(false);
      }
    }

    document.getElementById("approveBtn").onclick = () => handleDecision("Approved");
    document.getElementById("rejectBtn").onclick = () => handleDecision("Rejected");

    function extractFormIdsFromHTML(html) {
      const wrapper = document.createElement('div');
      wrapper.innerHTML = html;
      const table = wrapper.querySelector('table');
      if (!table) return [];

      const headers = Array.from(table.querySelectorAll("thead th")).map(th => th.textContent.trim());
      const formIdIndex = headers.findIndex(h => h.toLowerCase().includes("formid"));
      if (formIdIndex === -1) return [];

      const rows = table.querySelectorAll("tbody tr");
      return Array.from(rows).map(row => row.children[formIdIndex]?.textContent?.trim()).filter(Boolean);
    }

    function simpleHash(str) {
      let hash = 5381;
      for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
      }
      return hash >>> 0;
    }

    async function fetchRawFileContent() {
      const rawUrl = `https://raw.githubusercontent.com/sajusathish/fuel-log-review/main/RefreshedData?t=${Date.now()}`;
      const response = await fetch(rawUrl, { cache: 'no-store' });
      if (!response.ok) throw new Error(`Failed fetching refreshed data: ${response.status}`);
      const text = await response.text();
      return text;
    }

    function compareFormIdLists(currentList, newList) {
      const currentSet = new Set(currentList);
      const newSet = new Set(newList);

      if (currentList.length !== newList.length) return true;
      for (const id of currentSet) {
        if (!newSet.has(id)) return true;
      }
      for (const id of newSet) {
        if (!currentSet.has(id)) return true;
      }
      return false;
    }

    async function pollForUpdate() {
      const statusText = document.getElementById("statusText");
      const currentTableHTML = document.getElementById("tableContainer").innerHTML;
      const currentFormIds = extractFormIdsFromHTML(currentTableHTML);

      let attempts = 0;
      const maxAttempts = 10;

      return new Promise(resolve => {
        const interval = setInterval(async () => {
          attempts++;
          try {
            const newHTML = await fetchRawFileContent();
            const newFormIds = extractFormIdsFromHTML(newHTML);

            if (compareFormIdLists(currentFormIds, newFormIds) || attempts >= maxAttempts) {
              clearInterval(interval);

              document.getElementById("tableContainer").innerHTML = newHTML;
              addSelectAllControl();
              addColumnResizers();

              if (compareFormIdLists(currentFormIds, newFormIds)) {
                statusText.textContent = `‚úÖ Table refreshed!`;
              } else {
                statusText.textContent = `‚ö†Ô∏è No updates found.`;
              }

              toggleButtonsDisabled(false);
              resolve(true);
            }
          } catch (err) {
            clearInterval(interval);
            statusText.textContent = `‚ùå Polling error: ${err.message}`;
            toggleButtonsDisabled(false);
            resolve(false);
          }
        }, 7000);
      });
    }

    async function refreshTable() {
      const statusText = document.getElementById("statusText");
      statusText.textContent = `Triggering refresh... ‚è≥`;
      toggleButtonsDisabled(true);

      try {
        const webhookResp = await fetch("https://webhooks.workato.com/webhooks/rest/b7ed69d5-2da6-44d3-befd-c64b497884e8/refreshtable", {
          method: "GET",
          cache: "no-store"
        });

        if (!webhookResp.ok) throw new Error(`Webhook trigger failed with status ${webhookResp.status}`);

        statusText.textContent = `Waiting for updated data... üîÑ`;
        await pollForUpdate();

      } catch (err) {
        statusText.textContent = `‚ùå Refresh failed: ${err.message}`;
        toggleButtonsDisabled(false);
      }
    }

    document.getElementById("refreshBtn").onclick = refreshTable;
  </script>
</body>
</html>
